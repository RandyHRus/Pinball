<!DOCTYPE html>
<html>
  <head>
    <title>Pinball</title>
  </head>
  <body>
    <script src="matter.js" type="text/javascript"></script>
    <script>
        let engine = Matter.Engine.create();

        engine.gravity.y = 1;

        let render = Matter.Render.create({
            element: document.body,
            engine: engine
        });

        FLIPPER_ANGLE_UP = Math.PI * -0.19;
        FLIPPER_ANGLE_DOWN = Math.PI * 0.19;
        FLIPPER_SPEED = 0.3;
        FLIPPER_LENGTH = 100;
        FLIPPER_WIDTH = 20;
        FLIPPER_OFFSET = 130;

        EDGE_WIDTH = 30;
        BOARD_WIDTH = 600;
        BOARD_HEIGHT = 650;

        RAMP_ANGLE = Math.PI * 0.04

        BALL_RADIUS = 20;

        CHARGE_LENGTH = 200;

        let ground = Matter.Bodies.rectangle(0,0, BOARD_WIDTH-70,EDGE_WIDTH, {isStatic: true});
        let ceiling = Matter.Bodies.rectangle(0,0,BOARD_WIDTH,EDGE_WIDTH, {isStatic: true});
        let leftWall = Matter.Bodies.rectangle(0,0,EDGE_WIDTH,BOARD_HEIGHT, {isStatic: true});
        let rightWall = Matter.Bodies.rectangle(0,0,EDGE_WIDTH,BOARD_HEIGHT, {isStatic: true});
        let ramp = Matter.Bodies.rectangle(0,0,BOARD_WIDTH-90,EDGE_WIDTH, {isStatic: true});

        let curve = Matter.Bodies.rectangle(0,0,100,20, {isStatic: true});

        let holder = Matter.Bodies.rectangle(0,0,EDGE_WIDTH,BOARD_HEIGHT-200, {isStatic: true});
        let holder2 = Matter.Bodies.rectangle(0,0,EDGE_WIDTH,BOARD_HEIGHT-200, {isStatic: true});
        let holder3 = Matter.Bodies.rectangle(0,0,EDGE_WIDTH,BOARD_HEIGHT-200, {isStatic: true});

        let ball = Matter.Bodies.circle(window.innerWidth/2+(BOARD_WIDTH/2)-(EDGE_WIDTH/2),300,BALL_RADIUS, {
            restitution: 1 //make ball bounce
        });

        let slingBumper = Matter.Bodies.rectangle(0,0,25,25);
        let slingShot = Matter.Constraint.create({
            pointA: {x:0,y:0},
            bodyB: slingBumper,
            stiffness: 0.05,
            length: 0,
            damping: 0
        })

        let leftFlipperBody = Matter.Bodies.rectangle(0, 0, FLIPPER_LENGTH, FLIPPER_WIDTH)
        let leftFlipper = {
            body: leftFlipperBody,
            pivot: Matter.Constraint.create({
                bodyA: leftFlipperBody,
                pointB: {x: window.innerWidth/2-FLIPPER_OFFSET , y: 500},
                pointA: {x: -40, y:0},
                length: 0,
                stiffness: 1
            }),
            state: "rest",
            keyDown: false,
            flip: 1
        }

        let rightFlipperBody = Matter.Bodies.rectangle(0, 0, FLIPPER_LENGTH, FLIPPER_WIDTH);
        let rightFlipper = {
            body: rightFlipperBody,
            pivot: Matter.Constraint.create({
                bodyA: rightFlipperBody,
                pointB: {x: window.innerWidth/2+FLIPPER_OFFSET , y: 500},
                pointA: {x: 40, y:0},
                length: 0,
                stiffness: 1
            }),
            state: "rest",
            keyDown: false,
            flip: -1
        }

        let slingPosition = {
            x: window.innerWidth/2 + (BOARD_WIDTH/2) - 20,
            y: window.innerHeight/2 + (BOARD_HEIGHT/2)
        }


        //Set flipper angles
        Matter.Body.setAngle(leftFlipper.body, FLIPPER_ANGLE_DOWN);
        Matter.Body.setAngle(rightFlipper.body, -FLIPPER_ANGLE_DOWN);

        //Set ramp angle
        Matter.Body.setAngle(ramp, RAMP_ANGLE);
        
        function reposition() {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;

            Matter.Body.setPosition(ground, {x: window.innerWidth/2, y: (window.innerHeight/2)+(BOARD_HEIGHT/2)-(EDGE_WIDTH/2)});
            Matter.Body.setPosition(ceiling, {x: window.innerWidth/2, y: (window.innerHeight/2)-(BOARD_HEIGHT/2)+(EDGE_WIDTH/2)});
            Matter.Body.setPosition(leftWall, {x: window.innerWidth/2-(BOARD_WIDTH/2)-(EDGE_WIDTH/2), y: window.innerHeight/2});
            Matter.Body.setPosition(rightWall, {x: window.innerWidth/2+(BOARD_WIDTH/2)+(EDGE_WIDTH/2), y: window.innerHeight/2});

            Matter.Body.setPosition(leftFlipper.body, {x: window.innerWidth/2-FLIPPER_OFFSET, y: 500});
            //Matter.Body.setPosition(leftFlipperPivot, {x: window.innerWidth/2-FLIPPER_OFFSET, y: 500});

            Matter.Body.setPosition(rightFlipper.body, {x: window.innerWidth/2+FLIPPER_OFFSET, y: 500});

            Matter.Body.setPosition(ramp, {x: window.innerWidth/2, y: (window.innerHeight/2)+(BOARD_HEIGHT/2)-(EDGE_WIDTH/2)-50});

            Matter.Body.setPosition(holder, {x: window.innerWidth/2+(BOARD_WIDTH/2)-(EDGE_WIDTH/2)-(BALL_RADIUS*2)-10, y: window.innerHeight/2});
            Matter.Body.setPosition(holder2, {x: window.innerWidth/2+(BOARD_WIDTH/2)-140, y: window.innerHeight/2-20});
            Matter.Body.setPosition(holder3, {x: window.innerWidth/2-(BOARD_WIDTH/2)+140, y: window.innerHeight/2-100});

            Matter.Body.setPosition(slingBumper, slingPosition);
            slingShot.pointA = slingPosition;

            Matter.Body.setAngle(curve, Math.PI * 0.25);
            Matter.Body.setPosition(curve, {x: window.innerWidth/2+(BOARD_WIDTH/2)-(EDGE_WIDTH/2), y: window.innerHeight/2 - (BOARD_HEIGHT/2)+50});
        }

        update();

        function update() {

            let flippers = [leftFlipper, rightFlipper];

            for (let flipper of flippers) {
                switch (flipper.state) {
                    case ("rest"):
                        Matter.Body.setAngle(flipper.body, flipper.flip*FLIPPER_ANGLE_DOWN);
                        Matter.Body.setAngularVelocity(flipper.body, 0);
                        if (flipper.keyDown) {
                            flipper.state = "movingUp";
                        }
                        break;
                    case ("movingUp"):
                        Matter.Body.setAngularVelocity(flipper.body, flipper.flip*-FLIPPER_SPEED);
                        if (flipper.flip*flipper.body.angle <= FLIPPER_ANGLE_UP) {
                            if (!flipper.keyDown) {
                                flipper.state = "movingDown";
                            } else {
                                flipper.state = "restUp"
                            }
                        }
                        break;
                    case ("restUp"): 
                        Matter.Body.setAngle(flipper.body, flipper.flip*FLIPPER_ANGLE_UP);
                        Matter.Body.setAngularVelocity(flipper.body, 0);
                        if (!flipper.keyDown) {
                            flipper.state = "movingDown";
                        }
                        break;
                    case ("movingDown"):
                        Matter.Body.setAngularVelocity(flipper.body, flipper.flip*FLIPPER_SPEED);
                        if (flipper.flip*flipper.body.angle >= FLIPPER_ANGLE_DOWN) {
                            flipper.state = "rest";
                        }
                        break;
                }
            }

            requestAnimationFrame(function() {
                update();
            })
        }

        let shooting = false;

        function shootBall() {
            if (shooting) {
                return;
            }
            else {
                shooting = true;
                Matter.Body.setPosition(slingBumper, {x: slingPosition.x, y: slingPosition.y+300});
                setTimeout(function() {shooting=false}, 1000)
            }
        }

        window.addEventListener("resize", function(){
            reposition();
        });
        
        window.addEventListener("keydown", event => {
            if (event.keyCode == 65) { //Left
                leftFlipper.keyDown = true;
            } else if (event.keyCode == 68) { //right
                rightFlipper.keyDown = true;
            } else if (event.keyCode == 82) { //r
                shootBall();
            }
        });

        window.addEventListener("keyup", event => {
            
            if (event.keyCode == 65) { //Left
                leftFlipper.keyDown = false;
            } else if (event.keyCode == 68) { //right
                rightFlipper.keyDown = false;
            }
        });

        reposition();

        /*
        * Mouse
        */
        let mouse = Matter.Mouse.create(render.canvas);
        let mouseConstraint = Matter.MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                render: {visible: false}
            }
        })
        render.mouse = mouse;

        /*
        * Render
        */
        Matter.World.add(engine.world, [ball,ground,leftWall,rightWall,ceiling,mouseConstraint,slingBumper, slingShot,ramp,holder, holder2, holder3, curve, leftFlipper.body, leftFlipper.pivot, rightFlipper.body, rightFlipper.pivot]);

        Matter.Runner.run(engine);
        Matter.Render.run(render);

    </script>
  </body>
</html>